<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/Daplie/node-letsencrypt#readme"

    >letsencrypt (v2.1.8)</a>
</h1>
<h4>Let's Encrypt for node.js on npm</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.letsencrypt">module letsencrypt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.letsencrypt._undefine">
            function <span class="apidocSignatureSpan">letsencrypt.</span>_undefine
            <span class="apidocSignatureSpan">(le)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.letsencrypt.create">
            function <span class="apidocSignatureSpan">letsencrypt.</span>create
            <span class="apidocSignatureSpan">(le)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">letsencrypt.</span>rsaKeySize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">letsencrypt.</span>LE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">letsencrypt.</span>_undefined</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">letsencrypt.</span>challengeTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">letsencrypt.</span>core</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">letsencrypt.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">letsencrypt.</span>middleware</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">letsencrypt.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">letsencrypt.</span>acmeChallengePrefix</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">letsencrypt.</span>challengeType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">letsencrypt.</span>productionServerUrl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">letsencrypt.</span>stagingServerUrl</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.letsencrypt._undefine">module letsencrypt._undefine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.letsencrypt._undefine._undefine">
            function <span class="apidocSignatureSpan">letsencrypt.</span>_undefine
            <span class="apidocSignatureSpan">(le)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.letsencrypt.core">module letsencrypt.core</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.letsencrypt.core.create">
            function <span class="apidocSignatureSpan">letsencrypt.core.</span>create
            <span class="apidocSignatureSpan">(le)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.letsencrypt.create">module letsencrypt.create</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.letsencrypt.create.create">
            function <span class="apidocSignatureSpan">letsencrypt.</span>create
            <span class="apidocSignatureSpan">(le)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.letsencrypt.middleware">module letsencrypt.middleware</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.letsencrypt.middleware.create">
            function <span class="apidocSignatureSpan">letsencrypt.middleware.</span>create
            <span class="apidocSignatureSpan">(le)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.letsencrypt.utils">module letsencrypt.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.letsencrypt.utils.attachCertInfo">
            function <span class="apidocSignatureSpan">letsencrypt.utils.</span>attachCertInfo
            <span class="apidocSignatureSpan">(results)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.letsencrypt.utils.isValidDomain">
            function <span class="apidocSignatureSpan">letsencrypt.utils.</span>isValidDomain
            <span class="apidocSignatureSpan">(domain)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.letsencrypt.utils.merge">
            function <span class="apidocSignatureSpan">letsencrypt.utils.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.letsencrypt.utils.testEmail">
            function <span class="apidocSignatureSpan">letsencrypt.utils.</span>testEmail
            <span class="apidocSignatureSpan">(email)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.letsencrypt.utils.tplCopy">
            function <span class="apidocSignatureSpan">letsencrypt.utils.</span>tplCopy
            <span class="apidocSignatureSpan">(copy)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.letsencrypt" id="apidoc.module.letsencrypt">module letsencrypt</a></h1>


    <h2>
        <a href="#apidoc.element.letsencrypt._undefine" id="apidoc.element.letsencrypt._undefine">
        function <span class="apidocSignatureSpan">letsencrypt.</span>_undefine
        <span class="apidocSignatureSpan">(le)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_undefine = function (le) {
  Object.keys(LE._undefined).forEach(function (key) {
    if (!(key in le)) {
      le[key] = u;
    }
  });

  return le;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      le.challenges[&#x27;dns-01&#x27;] = require(&#x27;le-challenge-dns&#x27;).create({ debug: le.debug });
    } catch(e) {
      // not yet implemented
    }
  }
}

le = LE.<span class="apidocCodeKeywordSpan">_undefine</span>(le);
le.acmeChallengePrefix = LE.acmeChallengePrefix;
le.rsaKeySize = le.rsaKeySize || LE.rsaKeySize;
le.challengeType = le.challengeType || LE.challengeType;
le._ipc = ipc;
le.agreeToTerms = le.agreeToTerms || function (args, agreeCb) {
  agreeCb(new Error(&#x22;&#x27;agreeToTerms&#x27; was not supplied to LE and &#x27;agreeTos&#x27; was not supplied to LE.register
&#x22;));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.letsencrypt.create" id="apidoc.element.letsencrypt.create">
        function <span class="apidocSignatureSpan">letsencrypt.</span>create
        <span class="apidocSignatureSpan">(le)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (le) {
  var PromiseA = require(&#x27;bluebird&#x27;);

  le.acme = le.acme || ACME.create({ debug: le.debug });
  le.store = le.store || require(&#x27;le-store-certbot&#x27;).create({ debug: le.debug });
  le.core = require(&#x27;./lib/core&#x27;);
  var log = le.log || _log;

  if (!le.challenges) {
    le.challenges = {};
  }
  if (!le.challenges[&#x27;http-01&#x27;]) {
    le.challenges[&#x27;http-01&#x27;] = require(&#x27;le-challenge-fs&#x27;).create({ debug: le.debug });
  }
  if (!le.challenges[&#x27;tls-sni-01&#x27;]) {
    le.challenges[&#x27;tls-sni-01&#x27;] = require(&#x27;le-challenge-sni&#x27;).create({ debug: le.debug });
  }
  if (!le.challenges[&#x27;dns-01&#x27;]) {
    try {
      le.challenges[&#x27;dns-01&#x27;] = require(&#x27;le-challenge-ddns&#x27;).create({ debug: le.debug });
    } catch(e) {
      try {
        le.challenges[&#x27;dns-01&#x27;] = require(&#x27;le-challenge-dns&#x27;).create({ debug: le.debug });
      } catch(e) {
        // not yet implemented
      }
    }
  }

  le = LE._undefine(le);
  le.acmeChallengePrefix = LE.acmeChallengePrefix;
  le.rsaKeySize = le.rsaKeySize || LE.rsaKeySize;
  le.challengeType = le.challengeType || LE.challengeType;
  le._ipc = ipc;
  le.agreeToTerms = le.agreeToTerms || function (args, agreeCb) {
    agreeCb(new Error(&#x22;&#x27;agreeToTerms&#x27; was not supplied to LE and &#x27;agreeTos&#x27; was not supplied to LE.register&#x22;));
  };

  if (!le.renewWithin) { le.renewWithin = 7 * DAY; }
  // renewBy has a default in le-sni-auto

  if (!le.server) {
    throw new Error(&#x22;opts.server must be set to &#x27;staging&#x27; or a production url, such as LE.productionServerUrl&#x27;&#x22;);
  }
  if (&#x27;staging&#x27; === le.server) {
    le.server = LE.stagingServerUrl;
  }
  else if (&#x27;production&#x27; === le.server) {
    le.server = LE.productionServerUrl;
  }

  if (le.acme.create) {
    le.acme = le.acme.create(le);
  }
  le.acme = PromiseA.promisifyAll(le.acme);
  le._acmeOpts = le.acme.getOptions();
  Object.keys(le._acmeOpts).forEach(function (key) {
    if (!(key in le)) {
      le[key] = le._acmeOpts[key];
    }
  });

  if (le.store.create) {
    le.store = le.store.create(le);
  }
  le.store = PromiseA.promisifyAll(le.store);
  le.store.accounts = PromiseA.promisifyAll(le.store.accounts);
  le.store.certificates = PromiseA.promisifyAll(le.store.certificates);
  le._storeOpts = le.store.getOptions();
  Object.keys(le._storeOpts).forEach(function (key) {
    if (!(key in le)) {
      le[key] = le._storeOpts[key];
    }
  });


  //
  // Backwards compat for &#x3c;= v2.1.7
  //
  if (le.challenge) {
    console.warn(&#x22;Deprecated use of le.challenge. Use le.challenges[&#x27;&#x22; + LE.challengeType + &#x22;&#x27;] instead.&#x22;);
    le.challenges[le.challengeType] = le.challenge;
  }

  LE.challengeTypes.forEach(function (challengeType) {
    var challenger = le.challenges[challengeType];

    if (!challenger) {
      return;
    }

    if (challenger.create) {
      challenger = le.challenges[challengeType] = challenger.create(le);
    }
    challenger = le.challenges[challengeType] = PromiseA.promisifyAll(challenger);
    le[&#x27;_challengeOpts_&#x27; + challengeType] = challenger.getOptions();
    Object.keys(le[&#x27;_challengeOpts_&#x27; + challengeType]).forEach(function (key) {
      if (!(key in le)) {
        le[key] = le[&#x27;_challengeOpts_&#x27; + challengeType][key];
      }
    });

    // TODO wrap these here and now with tplCopy?
    if (!challenger.set || 5 !== challenger.set.length) {
      throw new Error(&#x22;le.challenges[&#x22; + challengeType + &#x22;].set receives the wrong number of arguments.&#x22;
        + &#x22; You must define setChallenge as function (opts, domain, token, keyAuthorization, cb) { }&#x22;);
    }
    if (challenger.get &#x26;&#x26; 4 !== challenger.get.length) {
      throw new Error(&#x22;le.challenges[&#x22; + challengeType + &#x22;].get receives the wrong number of arguments.&#x22;
        + &#x22; You must define getChallenge as function (opts, domain, token, cb) { }&#x22;);
    }
    if (!challenger.remove || 4 !== challenger.remove.length) {
      throw new Error(&#x22;le.challenges[&#x22; + challengeType + &#x22;].remove receives the wrong number of arguments.&#x22;
        + &#x22; You must define removeChallenge as function (opts, domain, token, cb) { }&#x22;);
    }
    if (!challenger.loopback || 5 !== challenger.loopback.length) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Overly Simplified Example

Against my better judgement I&#x27;m providing a terribly oversimplified example
of how to use this library:

```javascript
var le = require(&#x27;letsencrypt&#x27;).<span class="apidocCodeKeywordSpan">create</span>({ server: &#x27;staging&#x27; });

var opts = {
domains: [&#x27;example.com&#x27;], email: &#x27;user@email.com&#x27;, agreeTos: true
};

le.register(opts).then(function (certs) {
console.log(certs);
...</pre></li>
    </ul>


























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.letsencrypt._undefine" id="apidoc.module.letsencrypt._undefine">module letsencrypt._undefine</a></h1>


    <h2>
        <a href="#apidoc.element.letsencrypt._undefine._undefine" id="apidoc.element.letsencrypt._undefine._undefine">
        function <span class="apidocSignatureSpan">letsencrypt.</span>_undefine
        <span class="apidocSignatureSpan">(le)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_undefine = function (le) {
  Object.keys(LE._undefined).forEach(function (key) {
    if (!(key in le)) {
      le[key] = u;
    }
  });

  return le;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      le.challenges[&#x27;dns-01&#x27;] = require(&#x27;le-challenge-dns&#x27;).create({ debug: le.debug });
    } catch(e) {
      // not yet implemented
    }
  }
}

le = LE.<span class="apidocCodeKeywordSpan">_undefine</span>(le);
le.acmeChallengePrefix = LE.acmeChallengePrefix;
le.rsaKeySize = le.rsaKeySize || LE.rsaKeySize;
le.challengeType = le.challengeType || LE.challengeType;
le._ipc = ipc;
le.agreeToTerms = le.agreeToTerms || function (args, agreeCb) {
  agreeCb(new Error(&#x22;&#x27;agreeToTerms&#x27; was not supplied to LE and &#x27;agreeTos&#x27; was not supplied to LE.register
&#x22;));
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.letsencrypt.core" id="apidoc.module.letsencrypt.core">module letsencrypt.core</a></h1>


    <h2>
        <a href="#apidoc.element.letsencrypt.core.create" id="apidoc.element.letsencrypt.core.create">
        function <span class="apidocSignatureSpan">letsencrypt.core.</span>create
        <span class="apidocSignatureSpan">(le)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (le) {
  var PromiseA = require(&#x27;bluebird&#x27;);
  var utils = require(&#x27;./utils&#x27;);
  var RSA = PromiseA.promisifyAll(require(&#x27;rsa-compat&#x27;).RSA);
  var log = le.log || _log; // allow custom log

  var core = {
    //
    // Helpers
    //
    getAcmeUrlsAsync: function (args) {
      var now = Date.now();

      // TODO check response header on request for cache time
      if ((now - le._ipc.acmeUrlsUpdatedAt) &#x3c; 10 * 60 * 1000) {
        return PromiseA.resolve(le._ipc.acmeUrls);
      }

      return le.acme.getAcmeUrlsAsync(args.server).then(function (data) {
        le._ipc.acmeUrlsUpdatedAt = Date.now();
        le._ipc.acmeUrls = data;

        return le._ipc.acmeUrls;
      });
    }


    //
    // The Main Enchilada
    //

    //
    // Accounts
    //
  , accounts: {
      // Accounts
      registerAsync: function (args) {
        var err;
        var copy = utils.merge(args, le);
        var disagreeTos;
        args = utils.tplCopy(copy);

        disagreeTos = (!args.agreeTos &#x26;&#x26; &#x27;undefined&#x27; !== typeof args.agreeTos);
        if (!args.email || disagreeTos || (parseInt(args.rsaKeySize, 10) &#x3c; 2048)) {
          err = new Error(
            &#x22;In order to register an account both &#x27;email&#x27; and &#x27;agreeTos&#x27; must be present&#x22;
              + &#x22; and &#x27;rsaKeySize&#x27; must be 2048 or greater.&#x22;
          );
          err.code = &#x27;E_ARGS&#x27;;
          return PromiseA.reject(err);
        }

        return utils.testEmail(args.email).then(function () {
          var keypairOpts = { public: true, pem: true };

          var promise = le.store.accounts.checkKeypairAsync(args).then(function (keypair) {
            if (keypair) {
              return RSA.import(keypair);
            }

            if (args.accountKeypair) {
              return le.store.accounts.setKeypairAsync(args, RSA.import(args.accountKeypair));
            }

            return RSA.generateKeypairAsync(args.rsaKeySize, 65537, keypairOpts).then(function (keypair) {
              keypair.privateKeyPem = RSA.exportPrivatePem(keypair);
              keypair.publicKeyPem = RSA.exportPublicPem(keypair);
              keypair.privateKeyJwk = RSA.exportPrivateJwk(keypair);
              return le.store.accounts.setKeypairAsync(args, keypair);
            });
          });

          return promise.then(function (keypair) {
            // Note: the ACME urls are always fetched fresh on purpose
            // TODO is this the right place for this?
            return core.getAcmeUrlsAsync(args).then(function (urls) {
              args._acmeUrls = urls;

              return le.acme.registerNewAccountAsync({
                email: args.email
              , newRegUrl: args._acmeUrls.newReg
              , agreeToTerms: function (tosUrl, agreeCb) {
                  if (true === args.agreeTos || tosUrl === args.agreeTos || tosUrl === le.agreeToTerms) {
                    agreeCb(null, tosUrl);
                    return;
                  }

                  // args.email = email;      // already there
                  // args.domains = domains   // already there
                  args.tosUrl = tosUrl;
                  le.agreeToTerms(args, agreeCb);
                }
              , accountKeypair: keypair

              , debug: le.debug || args.debug
              }).then(function (receipt) {
                var reg = {
                  keypair: keypair
                , receipt: receipt
                , email: args.email
                };

                // TODO move templating of arguments to right here?
                return le.store.accounts.setAsync(args, reg).then(function (account) {
                  // should now have account.id and account.accountId
                  args.account = account;
                  args.accountId = account.id;
                  return account;
                });
              });
            });
          });
        });
      }

      // Accounts
    , getAsync: function (args) {
        return core.accounts.checkAsync(args).then(function (account) {
          if (account) {
            return account;
          } else { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Overly Simplified Example

Against my better judgement I&#x27;m providing a terribly oversimplified example
of how to use this library:

```javascript
var le = require(&#x27;letsencrypt&#x27;).<span class="apidocCodeKeywordSpan">create</span>({ server: &#x27;staging&#x27; });

var opts = {
domains: [&#x27;example.com&#x27;], email: &#x27;user@email.com&#x27;, agreeTos: true
};

le.register(opts).then(function (certs) {
console.log(certs);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.letsencrypt.create" id="apidoc.module.letsencrypt.create">module letsencrypt.create</a></h1>


    <h2>
        <a href="#apidoc.element.letsencrypt.create.create" id="apidoc.element.letsencrypt.create.create">
        function <span class="apidocSignatureSpan">letsencrypt.</span>create
        <span class="apidocSignatureSpan">(le)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (le) {
  var PromiseA = require(&#x27;bluebird&#x27;);

  le.acme = le.acme || ACME.create({ debug: le.debug });
  le.store = le.store || require(&#x27;le-store-certbot&#x27;).create({ debug: le.debug });
  le.core = require(&#x27;./lib/core&#x27;);
  var log = le.log || _log;

  if (!le.challenges) {
    le.challenges = {};
  }
  if (!le.challenges[&#x27;http-01&#x27;]) {
    le.challenges[&#x27;http-01&#x27;] = require(&#x27;le-challenge-fs&#x27;).create({ debug: le.debug });
  }
  if (!le.challenges[&#x27;tls-sni-01&#x27;]) {
    le.challenges[&#x27;tls-sni-01&#x27;] = require(&#x27;le-challenge-sni&#x27;).create({ debug: le.debug });
  }
  if (!le.challenges[&#x27;dns-01&#x27;]) {
    try {
      le.challenges[&#x27;dns-01&#x27;] = require(&#x27;le-challenge-ddns&#x27;).create({ debug: le.debug });
    } catch(e) {
      try {
        le.challenges[&#x27;dns-01&#x27;] = require(&#x27;le-challenge-dns&#x27;).create({ debug: le.debug });
      } catch(e) {
        // not yet implemented
      }
    }
  }

  le = LE._undefine(le);
  le.acmeChallengePrefix = LE.acmeChallengePrefix;
  le.rsaKeySize = le.rsaKeySize || LE.rsaKeySize;
  le.challengeType = le.challengeType || LE.challengeType;
  le._ipc = ipc;
  le.agreeToTerms = le.agreeToTerms || function (args, agreeCb) {
    agreeCb(new Error(&#x22;&#x27;agreeToTerms&#x27; was not supplied to LE and &#x27;agreeTos&#x27; was not supplied to LE.register&#x22;));
  };

  if (!le.renewWithin) { le.renewWithin = 7 * DAY; }
  // renewBy has a default in le-sni-auto

  if (!le.server) {
    throw new Error(&#x22;opts.server must be set to &#x27;staging&#x27; or a production url, such as LE.productionServerUrl&#x27;&#x22;);
  }
  if (&#x27;staging&#x27; === le.server) {
    le.server = LE.stagingServerUrl;
  }
  else if (&#x27;production&#x27; === le.server) {
    le.server = LE.productionServerUrl;
  }

  if (le.acme.create) {
    le.acme = le.acme.create(le);
  }
  le.acme = PromiseA.promisifyAll(le.acme);
  le._acmeOpts = le.acme.getOptions();
  Object.keys(le._acmeOpts).forEach(function (key) {
    if (!(key in le)) {
      le[key] = le._acmeOpts[key];
    }
  });

  if (le.store.create) {
    le.store = le.store.create(le);
  }
  le.store = PromiseA.promisifyAll(le.store);
  le.store.accounts = PromiseA.promisifyAll(le.store.accounts);
  le.store.certificates = PromiseA.promisifyAll(le.store.certificates);
  le._storeOpts = le.store.getOptions();
  Object.keys(le._storeOpts).forEach(function (key) {
    if (!(key in le)) {
      le[key] = le._storeOpts[key];
    }
  });


  //
  // Backwards compat for &#x3c;= v2.1.7
  //
  if (le.challenge) {
    console.warn(&#x22;Deprecated use of le.challenge. Use le.challenges[&#x27;&#x22; + LE.challengeType + &#x22;&#x27;] instead.&#x22;);
    le.challenges[le.challengeType] = le.challenge;
  }

  LE.challengeTypes.forEach(function (challengeType) {
    var challenger = le.challenges[challengeType];

    if (!challenger) {
      return;
    }

    if (challenger.create) {
      challenger = le.challenges[challengeType] = challenger.create(le);
    }
    challenger = le.challenges[challengeType] = PromiseA.promisifyAll(challenger);
    le[&#x27;_challengeOpts_&#x27; + challengeType] = challenger.getOptions();
    Object.keys(le[&#x27;_challengeOpts_&#x27; + challengeType]).forEach(function (key) {
      if (!(key in le)) {
        le[key] = le[&#x27;_challengeOpts_&#x27; + challengeType][key];
      }
    });

    // TODO wrap these here and now with tplCopy?
    if (!challenger.set || 5 !== challenger.set.length) {
      throw new Error(&#x22;le.challenges[&#x22; + challengeType + &#x22;].set receives the wrong number of arguments.&#x22;
        + &#x22; You must define setChallenge as function (opts, domain, token, keyAuthorization, cb) { }&#x22;);
    }
    if (challenger.get &#x26;&#x26; 4 !== challenger.get.length) {
      throw new Error(&#x22;le.challenges[&#x22; + challengeType + &#x22;].get receives the wrong number of arguments.&#x22;
        + &#x22; You must define getChallenge as function (opts, domain, token, cb) { }&#x22;);
    }
    if (!challenger.remove || 4 !== challenger.remove.length) {
      throw new Error(&#x22;le.challenges[&#x22; + challengeType + &#x22;].remove receives the wrong number of arguments.&#x22;
        + &#x22; You must define removeChallenge as function (opts, domain, token, cb) { }&#x22;);
    }
    if (!challenger.loopback || 5 !== challenger.loopback.length) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Overly Simplified Example

Against my better judgement I&#x27;m providing a terribly oversimplified example
of how to use this library:

```javascript
var le = require(&#x27;letsencrypt&#x27;).<span class="apidocCodeKeywordSpan">create</span>({ server: &#x27;staging&#x27; });

var opts = {
domains: [&#x27;example.com&#x27;], email: &#x27;user@email.com&#x27;, agreeTos: true
};

le.register(opts).then(function (certs) {
console.log(certs);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.letsencrypt.middleware" id="apidoc.module.letsencrypt.middleware">module letsencrypt.middleware</a></h1>


    <h2>
        <a href="#apidoc.element.letsencrypt.middleware.create" id="apidoc.element.letsencrypt.middleware.create">
        function <span class="apidocSignatureSpan">letsencrypt.middleware.</span>create
        <span class="apidocSignatureSpan">(le)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (le) {
  if (!le.challenges[&#x27;http-01&#x27;] || !le.challenges[&#x27;http-01&#x27;].get) {
    throw new Error(&#x22;middleware requires challenge plugin with get method&#x22;);
  }
  var log = le.log || _log;

  log(le.debug, &#x22;created middleware&#x22;);
  return function (_app) {
    if (_app &#x26;&#x26; &#x27;function&#x27; !== typeof _app) {
      throw new Error(&#x22;use le.middleware() or le.middleware(function (req, res) {})&#x22;);
    }
    var prefix = le.acmeChallengePrefix || &#x27;/.well-known/acme-challenge/&#x27;;

    return function (req, res, next) {
      if (0 !== req.url.indexOf(prefix)) {
        log(le.debug, &#x22;no match, skipping middleware&#x22;);
        if (&#x27;function&#x27; === typeof _app) {
          _app(req, res, next);
        }
        else if (&#x27;function&#x27; === typeof next) {
          next();
        }
        else {
          res.statusCode = 500;
          res.end(&#x22;[500] Developer Error: app.use(&#x27;/&#x27;, le.middleware()) or le.middleware(app)&#x22;);
        }
        return;
      }

      log(le.debug, &#x22;this must be tinder, &#x27;cuz it&#x27;s a match!&#x22;);

      var token = req.url.slice(prefix.length);
      var hostname = req.hostname || (req.headers.host || &#x27;&#x27;).toLowerCase().replace(/:.*/, &#x27;&#x27;);

      log(le.debug, &#x22;hostname&#x22;, hostname, &#x22;token&#x22;, token);

      var copy = utils.merge({ domains: [ hostname ] }, le);
      copy = utils.tplCopy(copy);

      // TODO tpl copy?
      // TODO need to restore challengeType
      le.challenges[&#x27;http-01&#x27;].get(copy, hostname, token, function (err, secret) {
        if (err || !token) {
          res.statusCode = 404;
          res.setHeader(&#x27;Content-Type&#x27;, &#x27;application/json; charset=utf-8&#x27;);
          res.end(&#x27;{ &#x22;error&#x22;: { &#x22;message&#x22;: &#x22;Error: These aren\&#x27;t the tokens you\&#x27;re looking for. Move along.&#x22; } }&#x27;);
          return;
        }

        res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain; charset=utf-8&#x27;);
        res.end(secret);
      });
    };
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Overly Simplified Example

Against my better judgement I&#x27;m providing a terribly oversimplified example
of how to use this library:

```javascript
var le = require(&#x27;letsencrypt&#x27;).<span class="apidocCodeKeywordSpan">create</span>({ server: &#x27;staging&#x27; });

var opts = {
domains: [&#x27;example.com&#x27;], email: &#x27;user@email.com&#x27;, agreeTos: true
};

le.register(opts).then(function (certs) {
console.log(certs);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.letsencrypt.utils" id="apidoc.module.letsencrypt.utils">module letsencrypt.utils</a></h1>


    <h2>
        <a href="#apidoc.element.letsencrypt.utils.attachCertInfo" id="apidoc.element.letsencrypt.utils.attachCertInfo">
        function <span class="apidocSignatureSpan">letsencrypt.utils.</span>attachCertInfo
        <span class="apidocSignatureSpan">(results)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">attachCertInfo = function (results) {
  // XXX Note: Parsing the certificate info comes at a great cost (~500kb)
  var getCertInfo = require(&#x27;certpem&#x27;).info;
  var certInfo = getCertInfo(results.cert);

  // subject, altnames, issuedAt, expiresAt
  Object.keys(certInfo).forEach(function (key) {
    results[key] = certInfo[key];
  });

  return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var copy = utils.merge(args, le);
  utils.tplCopy(copy);

  // returns pems
  return le.store.certificates.checkAsync(copy).then(function (cert) {
    if (cert) {
      log(args.debug, &#x27;checkAsync found existing certificates&#x27;);
      return utils.<span class="apidocCodeKeywordSpan">attachCertInfo</span>(cert);
    }

    log(args.debug, &#x27;checkAsync failed to find certificates&#x27;);
    return null;
  });
}
// Certificates
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.letsencrypt.utils.isValidDomain" id="apidoc.element.letsencrypt.utils.isValidDomain">
        function <span class="apidocSignatureSpan">letsencrypt.utils.</span>isValidDomain
        <span class="apidocSignatureSpan">(domain)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidDomain = function (domain) {
  if (re.test(domain)) {
    return domain;
  }

  domain = punycode.toASCII(domain);

  if (re.test(domain)) {
    return domain;
  }

  return &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.letsencrypt.utils.merge" id="apidoc.element.letsencrypt.utils.merge">
        function <span class="apidocSignatureSpan">letsencrypt.utils.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function () {
  var allDefaults = Array.prototype.slice.apply(arguments);
  var args = allDefaults.shift();
  var copy = {};

  allDefaults.forEach(function (defaults) {
    Object.keys(defaults).forEach(function (key) {
      copy[key] = defaults[key];
    });
  });

  Object.keys(args).forEach(function (key) {
    copy[key] = args[key];
  });

  return copy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  le.sni = le.sni || require(&#x27;le-sni-auto&#x27;);
  if (le.sni.create) {
    le.sni = le.sni.create(le);
  }
  le.httpsOptions.SNICallback = le.sni.sniCallback;
}
if (!le.httpsOptions.key || !le.httpsOptions.cert) {
  le.httpsOptions = require(&#x27;localhost.daplie.com-certificates&#x27;).<span class="apidocCodeKeywordSpan">merge</span>(le.httpsOptions
);
}
/*
le.sni = PromiseA.promisifyAll(le.sni);
le._sniOpts = le.sni.getOptions();
Object.keys(le._sniOpts).forEach(function (key) {
  if (!(key in le)) {
    le[key] = le._sniOpts[key];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.letsencrypt.utils.testEmail" id="apidoc.element.letsencrypt.utils.testEmail">
        function <span class="apidocSignatureSpan">letsencrypt.utils.</span>testEmail
        <span class="apidocSignatureSpan">(email)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">testEmail = function (email) {
  var parts = (email||&#x27;&#x27;).split(&#x27;@&#x27;);
  var err;

  if (2 !== parts.length || !parts[0] || !parts[1]) {
    err = new Error(&#x22;malformed email address &#x27;&#x22; + email + &#x22;&#x27;&#x22;);
    err.code = &#x27;E_EMAIL&#x27;;
    return PromiseA.reject(err);
  }

  return dns.resolveMxAsync(parts[1]).then(function (records) {
    // records only returns when there is data
    if (!records.length) {
      throw new Error(&#x22;sanity check fail: success, but no MX records returned&#x22;);
    }
    return email;
  }, function (err) {
    if (&#x27;ENODATA&#x27; === err.code) {
      err = new Error(&#x22;no MX records found for &#x27;&#x22; + parts[1] + &#x22;&#x27;&#x22;);
      err.code = &#x27;E_EMAIL&#x27;;
      return PromiseA.reject(err);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  &#x22;In order to register an account both &#x27;email&#x27; and &#x27;agreeTos&#x27; must be present&#x22;
    + &#x22; and &#x27;rsaKeySize&#x27; must be 2048 or greater.&#x22;
);
err.code = &#x27;E_ARGS&#x27;;
return PromiseA.reject(err);
        }

        return utils.<span class="apidocCodeKeywordSpan">testEmail</span>(args.email).then(function () {
var keypairOpts = { public: true, pem: true };

var promise = le.store.accounts.checkKeypairAsync(args).then(function (keypair) {
  if (keypair) {
    return RSA.import(keypair);
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.letsencrypt.utils.tplCopy" id="apidoc.element.letsencrypt.utils.tplCopy">
        function <span class="apidocSignatureSpan">letsencrypt.utils.</span>tplCopy
        <span class="apidocSignatureSpan">(copy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tplCopy = function (copy) {
  var homedir = require(&#x27;homedir&#x27;)();
  var tplKeys;

  copy.hostnameGet = function (copy) {
    return (copy.domains || [])[0] || copy.domain;
  };

  Object.keys(copy).forEach(function (key) {
    var newName;
    if (!/Get$/.test(key)) {
      return;
    }

    newName = key.replace(/Get$/, &#x27;&#x27;);
    copy[newName] = copy[newName] || copy[key](copy);
  });

  tplKeys = Object.keys(copy);
  tplKeys.sort(function (a, b) {
    return b.length - a.length;
  });

  tplKeys.forEach(function (key) {
    if (&#x27;string&#x27; !== typeof copy[key]) {
      return;
    }

    copy[key] = copy[key].replace(homeRe, homedir + path.sep);
  });

  tplKeys.forEach(function (key) {
    if (&#x27;string&#x27; !== typeof copy[key]) {
      return;
    }

    tplKeys.forEach(function (tplname) {
      if (!copy[tplname]) {
        // what can&#x27;t be templated now may be templatable later
        return;
      }
      copy[key] = copy[key].replace(&#x27;:&#x27; + tplname, copy[tplname]);
    });
  });

  return copy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    //
  , accounts: {
      // Accounts
      registerAsync: function (args) {
var err;
var copy = utils.merge(args, le);
var disagreeTos;
args = utils.<span class="apidocCodeKeywordSpan">tplCopy</span>(copy);

disagreeTos = (!args.agreeTos &#x26;&#x26; &#x27;undefined&#x27; !== typeof args.agreeTos);
if (!args.email || disagreeTos || (parseInt(args.rsaKeySize, 10) &#x3c; 2048)) {
  err = new Error(
    &#x22;In order to register an account both &#x27;email&#x27; and &#x27;agreeTos&#x27; must be present&#x22;
      + &#x22; and &#x27;rsaKeySize&#x27; must be 2048 or greater.&#x22;
  );
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
